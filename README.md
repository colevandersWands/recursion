learning objectives
* a formal understanding of recursion
    * replacing recursive calls with known return values
    * manually solving in parallel steps
    * defining recursive functions in notation
* visualizing recursive solution trees with logging
* breaking down & labeling components of recursive solutions
* thinking 'locally' 
    * not trying to understand the whole recursive branching
    * reasoning instead about a single call and the 4 components therein
    * trusting the recursive call to do it's job
* building recursive solutions in a structured way
* light js call-stack
* dummy testing


manual recursion
1. given a formal recursive definition
2. identify the ...
    * base case
    * turn-around
    * break-down
    * recurse
    * build-up
3. establish several faith-cases by hand

analyzing exercises:
1. given code & problem description
2. identify the ...
    * base case
    * turn-around
    * break-down
    * recurse
    * build-up
3. write a formal definition for this challenge
4. develop the build-up
5. manually step-through several faith-cases with the solution and your build-up
6. log the solution & run it with your test cases
7. (maybe: id'ing when infinite loops are likely?)


building exercises:
1. given explanation of problem (& formal notation)?
2. identify the ...
    * base case
    * turn-around
    * break-down
    * recurse
    * build-up
3. establish several 'faith cases' by hand
4. develop & test the components in isolation
5. put together and test your full solution
6. log the solution & run it to inspect the solution structure


planning recursion
1. given a challenge that can be solved by recursion
2. identify the ...
    * base case
    * turn-around
    * break-down
    * recurse
    * build-up 
3. develop & test the components in isolation
4. put together and test your full solution
5. log the solution & run it to inspect the solution structure
6. dummy testing